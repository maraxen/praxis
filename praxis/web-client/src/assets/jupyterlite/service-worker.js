"use strict"; const CACHE = "precache", broadcast = new BroadcastChannel("/sw-api.v1"); let enableCache = !1; function onInstall(e) { self.skipWaiting(), e.waitUntil(cacheAll()) } function onActivate(e) { const t = new URL(location.href).searchParams; enableCache = "true" === t.get("enableCache"), e.waitUntil(self.clients.claim()) } async function onFetch(e) { const { request: t } = e, a = new URL(e.request.url); if ("/api/service-worker-heartbeat" === a.pathname) return void e.respondWith(new Response("ok")); let n = null; shouldBroadcast(a) ? n = broadcastOne(t, a) : shouldDrop(t, a) || (n = maybeFromCache(e)), n && e.respondWith(n.then ? n.then(addCoepHeaders) : addCoepHeaders(n)) } function addCoepHeaders(e) { if (!e || !(e instanceof Response)) return e; const t = new Headers(e.headers); t.set("Cross-Origin-Embedder-Policy", "credentialless"), t.set("Cross-Origin-Resource-Policy", "cross-origin"); return new Response(e.body, { status: e.status, statusText: e.statusText, headers: t }) } async function maybeFromCache(e) { const { request: t } = e; if (!enableCache) return await fetch(t); let a = await fromCache(t); return a ? e.waitUntil(refetch(t)) : (a = await fetch(t), e.waitUntil(updateCache(t, a.clone()))), a } async function fromCache(e) { const t = await openCache(), a = await t.match(e); return a && 404 !== a.status ? a : null } async function refetch(e) { const t = await fetch(e); return await updateCache(e, t), t } function shouldBroadcast(e) { return e.origin === location.origin && (e.pathname.includes("/api/drive") || e.pathname.includes("/api/stdin/")) } function shouldDrop(e, t) { return "GET" !== e.method || null === t.origin.match(/^http/) || t.pathname.includes("/api/") } async function broadcastOne(e, t) { const a = await e.json(), n = new Promise((e => { const t = n => { const c = n.data; if (c.browsingContextId !== a.browsingContextId || c.requestId !== a.requestId) return; const s = c.response; e(new Response(JSON.stringify(s))), broadcast.removeEventListener("message", t) }; broadcast.addEventListener("message", t) })); return a.pathname = t.pathname, broadcast.postMessage(a), await n } async function openCache() { return await caches.open(CACHE) } async function updateCache(e, t) { return (await openCache()).put(e, t) } async function cacheAll() { const e = await openCache(); return await e.addAll([]) } self.addEventListener("install", onInstall), self.addEventListener("activate", onActivate), self.addEventListener("fetch", onFetch);