diff --git a/praxis/web-client/src/app/app.ts b/praxis/web-client/src/app/app.ts
index 7bca0a2..6745a48 100644
--- a/praxis/web-client/src/app/app.ts
+++ b/praxis/web-client/src/app/app.ts
@@ -1,7 +1,12 @@
-import { Component, signal, inject } from '@angular/core';
+import { Component, signal, inject, OnInit } from '@angular/core';
 import { RouterOutlet } from '@angular/router';
+import { MatDialog } from '@angular/material/dialog';
 import { SqliteService } from './core/services/sqlite';
 import { ApiConfigService } from './core/services/api-config.service';
+import { SessionRecoveryService } from './core/services/session-recovery.service';
+import { SessionRecoveryComponent } from './core/components/session-recovery/session-recovery.component';
+import { filter, switchMap } from 'rxjs/operators';
+import { forkJoin } from 'rxjs';
 
 @Component({
   selector: 'app-root',
@@ -12,9 +17,11 @@ import { ApiConfigService } from './core/services/api-config.service';
     '[attr.data-sqlite-ready]': 'sqlite.isReady() ? \"true\" : \"false\"'
   }
 })
-export class App {
+export class App implements OnInit {
   protected readonly title = signal('web-client');
   private apiConfig = inject(ApiConfigService);
+  private sessionRecoveryService = inject(SessionRecoveryService);
+  private dialog = inject(MatDialog);
 
   constructor(protected sqlite: SqliteService) {
     // Initialize API client configuration
@@ -23,4 +30,27 @@ export class App {
     // Expose for E2E testing (legacy - use data-sqlite-ready attribute instead)
     (window as any).sqliteService = this.sqlite;
   }
+
+  ngOnInit(): void {
+    this.sessionRecoveryService.checkForOrphanedRuns().subscribe(orphanedRuns => {
+      if (orphanedRuns.length > 0) {
+        const dialogRef = this.dialog.open(SessionRecoveryComponent, {
+          data: { runs: orphanedRuns },
+          disableClose: true,
+        });
+
+        dialogRef.afterClosed().pipe(
+          filter(result => result === 'mark-as-failed'),
+          switchMap(() => {
+            const updates = orphanedRuns.map(run =>
+              this.sessionRecoveryService.markAsFailed(run.accession_id!)
+            );
+            return forkJoin(updates);
+          })
+        ).subscribe(() => {
+          console.log('Orphaned runs marked as failed.');
+        });
+      }
+    });
+  }
 }
diff --git a/praxis/web-client/src/app/core/components/session-recovery/session-recovery.component.ts b/praxis/web-client/src/app/core/components/session-recovery/session-recovery.component.ts
new file mode 100644
index 0000000..d6868ca
--- /dev/null
+++ b/praxis/web-client/src/app/core/components/session-recovery/session-recovery.component.ts
@@ -0,0 +1,41 @@
+import { Component, Inject } from '@angular/core';
+import { CommonModule } from '@angular/common';
+import { MatButtonModule } from '@angular/material/button';
+import { MAT_DIALOG_DATA, MatDialogRef, MatDialogModule } from '@angular/material/dialog';
+import { OrphanedRun } from '@core/services/session-recovery.service';
+
+@Component({
+  selector: 'app-session-recovery',
+  standalone: true,
+  imports: [CommonModule, MatDialogModule, MatButtonModule],
+  template: `
+    <h1 mat-dialog-title>Session Recovery</h1>
+    <div mat-dialog-content>
+      <p>The following protocol run was interrupted:</p>
+      <ul>
+        <li *ngFor="let run of data.runs">
+          {{ run.name }} ({{ run.accession_id }})
+        </li>
+      </ul>
+      <p>Would you like to mark {{ data.runs.length > 1 ? 'them' : 'it' }} as failed?</p>
+    </div>
+    <div mat-dialog-actions>
+      <button mat-button (click)="onDismiss()">Dismiss</button>
+      <button mat-button color="warn" (click)="onMarkAsFailed()">Mark as Failed</button>
+    </div>
+  `,
+})
+export class SessionRecoveryComponent {
+  constructor(
+    public dialogRef: MatDialogRef<SessionRecoveryComponent>,
+    @Inject(MAT_DIALOG_DATA) public data: { runs: OrphanedRun[] }
+  ) {}
+
+  onDismiss(): void {
+    this.dialogRef.close();
+  }
+
+  onMarkAsFailed(): void {
+    this.dialogRef.close('mark-as-failed');
+  }
+}
diff --git a/praxis/web-client/src/app/core/db/schema.ts b/praxis/web-client/src/app/core/db/schema.ts
index cbebb8c..1298d3b 100644
--- a/praxis/web-client/src/app/core/db/schema.ts
+++ b/praxis/web-client/src/app/core/db/schema.ts
@@ -379,6 +379,17 @@ export interface ProtocolAssetRequirement {
   protocol_definition_accession_id: string;
 }
 
+/**
+ * Metadata for a protocol run, stored in properties_json
+ */
+export interface RunMetadata {
+  notes?: string;
+  simulation_mode?: boolean;
+  lastHeartbeat?: number; // Unix timestamp (ms)
+  checkpointStep?: number;
+  checkpointState?: any;
+}
+
 /**
  * Interface for the 'protocol_runs' table
  */
@@ -387,7 +398,7 @@ export interface ProtocolRun {
   created_at: string | null;
   updated_at: string | null;
   name: string | null;
-  properties_json: Record<string, unknown> | null;
+  properties_json: RunMetadata | null;
   start_time: string | null;
   end_time: string | null;
   data_directory_path: string | null;
diff --git a/praxis/web-client/src/app/core/services/session-recovery.service.spec.ts b/praxis/web-client/src/app/core/services/session-recovery.service.spec.ts
new file mode 100644
index 0000000..7014ec9
--- /dev/null
+++ b/praxis/web-client/src/app/core/services/session-recovery.service.spec.ts
@@ -0,0 +1,126 @@
+import { TestBed } from '@angular/core/testing';
+import { SessionRecoveryService, OrphanedRun } from './session-recovery.service';
+import { SqliteService } from './sqlite.service';
+import { of } from 'rxjs';
+import { ProtocolRunStatusValues } from '@core/db/enums';
+
+describe('SessionRecoveryService', () => {
+  let service: SessionRecoveryService;
+  let sqliteService: jasmine.SpyObj<SqliteService>;
+
+  const mockRuns: OrphanedRun[] = [
+    {
+      accession_id: '1',
+      name: 'run-1',
+      properties_json: { lastHeartbeat: Date.now() - 60000 }, // 1 minute ago
+      status: ProtocolRunStatusValues.RUNNING,
+      created_at: '',
+      updated_at: '',
+      start_time: '',
+      end_time: '',
+      data_directory_path: '',
+      duration_ms: 0,
+      input_parameters_json: {},
+      resolved_assets_json: {},
+      output_data_json: {},
+      initial_state_json: {},
+      final_state_json: {},
+      created_by_user: {},
+      top_level_protocol_definition_accession_id: '',
+      protocol_definition_accession_id: ''
+    },
+    {
+      accession_id: '2',
+      name: 'run-2',
+      properties_json: { lastHeartbeat: Date.now() - 10000 }, // 10 seconds ago
+      status: ProtocolRunStatusValues.RUNNING,
+      created_at: '',
+      updated_at: '',
+      start_time: '',
+      end_time: '',
+      data_directory_path: '',
+      duration_ms: 0,
+      input_parameters_json: {},
+      resolved_assets_json: {},
+      output_data_json: {},
+      initial_state_json: {},
+      final_state_json: {},
+      created_by_user: {},
+      top_level_protocol_definition_accession_id: '',
+      protocol_definition_accession_id: ''
+    },
+    {
+      accession_id: '3',
+      name: 'run-3',
+      properties_json: { lastHeartbeat: Date.now() - 90000 }, // 1.5 minutes ago
+      status: ProtocolRunStatusValues.PAUSING,
+      created_at: '',
+      updated_at: '',
+      start_time: '',
+      end_time: '',
+      data_directory_path: '',
+      duration_ms: 0,
+      input_parameters_json: {},
+      resolved_assets_json: {},
+      output_data_json: {},
+      initial_state_json: {},
+      final_state_json: {},
+      created_by_user: {},
+      top_level_protocol_definition_accession_id: '',
+      protocol_definition_accession_id: ''
+    },
+  ];
+
+  beforeEach(() => {
+    const sqliteServiceSpy = jasmine.createSpyObj('SqliteService', ['protocolRuns']);
+    TestBed.configureTestingModule({
+      providers: [
+        SessionRecoveryService,
+        { provide: SqliteService, useValue: sqliteServiceSpy },
+      ],
+    });
+    service = TestBed.inject(SessionRecoveryService);
+    sqliteService = TestBed.inject(SqliteService) as jasmine.SpyObj<SqliteService>;
+  });
+
+  it('should be created', () => {
+    expect(service).toBeTruthy();
+  });
+
+  it('should identify orphaned runs', () => {
+    const protocolRunsRepoSpy = jasmine.createSpyObj('AsyncProtocolRunRepository', ['findByStatus']);
+    protocolRunsRepoSpy.findByStatus.and.returnValue(of(mockRuns));
+    sqliteService.protocolRuns = of(protocolRunsRepoSpy);
+
+    service.checkForOrphanedRuns().subscribe(orphanedRuns => {
+      expect(orphanedRuns.length).toBe(2);
+      expect(orphanedRuns.map(r => r.accession_id)).toEqual(['1', '3']);
+    });
+
+    expect(protocolRunsRepoSpy.findByStatus).toHaveBeenCalledWith([
+      ProtocolRunStatusValues.RUNNING,
+      ProtocolRunStatusValues.PAUSING,
+      ProtocolRunStatusValues.RESUMING,
+    ]);
+  });
+
+  it('should handle no orphaned runs', () => {
+    const protocolRunsRepoSpy = jasmine.createSpyObj('AsyncProtocolRunRepository', ['findByStatus']);
+    protocolRunsRepoSpy.findByStatus.and.returnValue(of(mockRuns.slice(1,2)));
+    sqliteService.protocolRuns = of(protocolRunsRepoSpy);
+
+    service.checkForOrphanedRuns().subscribe(orphanedRuns => {
+      expect(orphanedRuns.length).toBe(0);
+    });
+  });
+
+  it('should mark a run as failed', () => {
+    const protocolRunsRepoSpy = jasmine.createSpyObj('AsyncProtocolRunRepository', ['update']);
+    protocolRunsRepoSpy.update.and.returnValue(of(void 0));
+    sqliteService.protocolRuns = of(protocolRunsRepoSpy);
+
+    service.markAsFailed('1').subscribe(() => {
+      expect(protocolRunsRepoSpy.update).toHaveBeenCalledWith('1', { status: ProtocolRunStatusValues.FAILED });
+    });
+  });
+});
diff --git a/praxis/web-client/src/app/core/services/session-recovery.service.ts b/praxis/web-client/src/app/core/services/session-recovery.service.ts
new file mode 100644
index 0000000..fac8175
--- /dev/null
+++ b/praxis/web-client/src/app/core/services/session-recovery.service.ts
@@ -0,0 +1,46 @@
+import { Injectable, inject } from '@angular/core';
+import { Observable, from } from 'rxjs';
+import { switchMap, map } from 'rxjs/operators';
+import { SqliteService } from 'src/app/core/services/sqlite/sqlite.service';
+import { ProtocolRun } from '@core/db/schema';
+import { ProtocolRunStatusValues } from '@core/db/enums';
+
+export type OrphanedRun = ProtocolRun;
+
+@Injectable({
+  providedIn: 'root'
+})
+export class SessionRecoveryService {
+  private sqliteService = inject(SqliteService);
+
+  /**
+   * Checks for orphaned protocol runs.
+   * An orphaned run is a run that has a status of 'running', 'pausing', or 'resuming'
+   * and has not had a heartbeat in the last 30 seconds.
+   */
+  checkForOrphanedRuns(): Observable<OrphanedRun[]> {
+    const staleThreshold = Date.now() - 30000; // 30 seconds
+    const activeStatuses = [
+      ProtocolRunStatusValues.RUNNING,
+      ProtocolRunStatusValues.PAUSING,
+      ProtocolRunStatusValues.RESUMING
+    ];
+
+    return this.sqliteService.protocolRuns.pipe(
+      switchMap(repo => from(repo.findByStatus(activeStatuses))),
+      map((runs: OrphanedRun[]) => runs.filter((run: OrphanedRun) => {
+        const lastHeartbeat = run.properties_json?.lastHeartbeat ?? 0;
+        return lastHeartbeat < staleThreshold;
+      }))
+    );
+  }
+
+  /**
+   * Marks an orphaned run as failed.
+   */
+  markAsFailed(runId: string): Observable<void> {
+    return this.sqliteService.protocolRuns.pipe(
+      switchMap(repo => from(repo.update(runId, { status: ProtocolRunStatusValues.FAILED })))
+    ).pipe(map(() => void 0));
+  }
+}
diff --git a/praxis/web-client/src/app/features/run-protocol/services/execution.service.ts b/praxis/web-client/src/app/features/run-protocol/services/execution.service.ts
index 3c0dc7b..6c607f6 100644
--- a/praxis/web-client/src/app/features/run-protocol/services/execution.service.ts
+++ b/praxis/web-client/src/app/features/run-protocol/services/execution.service.ts
@@ -47,6 +47,38 @@ export class ExecutionService {
   messages$ = this.messagesSubject.asObservable();
 
   private apiWrapper = inject(ApiWrapperService);
+  private heartbeatInterval?: ReturnType<typeof setInterval>;
+
+  /**
+   * Start sending heartbeats to the database
+   */
+  private startHeartbeat(runId: string): void {
+    this.heartbeatInterval = setInterval(() => {
+      this.sqliteService.protocolRuns.pipe(
+        switchMap(repo => repo.findById(runId)),
+        switchMap(run => {
+          if (run) {
+            const metadata = (run.properties_json || {}) as any;
+            metadata.lastHeartbeat = Date.now();
+            return this.sqliteService.protocolRuns.pipe(
+              switchMap(repo => repo.update(runId, { properties_json: metadata } as any))
+            );
+          }
+          return of(null);
+        })
+      ).subscribe();
+    }, 5000); // Every 5 seconds
+  }
+
+  /**
+   * Stop sending heartbeats
+   */
+  private stopHeartbeat(): void {
+    if (this.heartbeatInterval) {
+      clearInterval(this.heartbeatInterval);
+      this.heartbeatInterval = undefined;
+    }
+  }
 
   /**
    * Fetch protocol blob from backend or static assets
@@ -197,6 +229,9 @@ export class ExecutionService {
     // Execute asynchronously
     this.executeBrowserProtocol(protocolId, runId, parameters);
 
+    // Start heartbeat
+    this.startHeartbeat(runId);
+
     return of({ run_id: runId });
   }
 
@@ -314,7 +349,7 @@ export class ExecutionService {
       this.sqliteService.protocolRuns.pipe(
         switchMap(repo => repo.update(runId, { status: 'completed', end_time: new Date().toISOString() }))
       ).subscribe();
-
+      this.stopHeartbeat();
     } catch (error) {
       console.error('[Browser Execution Error]', error);
       const current = this._currentRun();
@@ -330,6 +365,7 @@ export class ExecutionService {
       this.sqliteService.protocolRuns.pipe(
         switchMap(repo => repo.update(runId, { status: 'failed', end_time: new Date().toISOString() }))
       ).subscribe();
+      this.stopHeartbeat();
     }
   }
 

